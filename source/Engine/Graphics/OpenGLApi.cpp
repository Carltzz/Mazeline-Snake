#include "OpenGLApi.h"
#include "MazelineEngine.h"

#include "GLew/glew.h"

#ifdef _WIN32
#include <Windows.h>
#include <gl/GL.h>
#endif

const char gl_default_vertex_p3[262] = {
	0x23, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x33, 0x33, 0x30, 0x0a, 0x6c, 0x61, 0x79,
	0x6f, 0x75, 0x74, 0x28, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x30,
	0x29, 0x20, 0x69, 0x6e, 0x20, 0x76, 0x65, 0x63, 0x33, 0x20, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78,
	0x3b, 0x0a, 0x6c, 0x61, 0x79, 0x6f, 0x75, 0x74, 0x28, 0x62, 0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67,
	0x20, 0x3d, 0x20, 0x30, 0x29, 0x20, 0x75, 0x6e, 0x69, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x63, 0x61,
	0x6d, 0x65, 0x72, 0x61, 0x20, 0x7b, 0x0a, 0x09, 0x6d, 0x61, 0x74, 0x34, 0x20, 0x6d, 0x6f, 0x64,
	0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x3b, 0x0a, 0x09, 0x6d, 0x61, 0x74, 0x34,
	0x20, 0x76, 0x69, 0x65, 0x77, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x3b, 0x0a, 0x09, 0x6d,
	0x61, 0x74, 0x34, 0x20, 0x70, 0x72, 0x6f, 0x6a, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x3b,
	0x0a, 0x7d, 0x3b, 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x28, 0x29, 0x20,
	0x7b, 0x0a, 0x09, 0x67, 0x6c, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d,
	0x20, 0x70, 0x72, 0x6f, 0x6a, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x20, 0x2a, 0x20, 0x76,
	0x69, 0x65, 0x77, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x20, 0x2a, 0x20, 0x6d, 0x6f, 0x64,
	0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x20, 0x2a, 0x20, 0x76, 0x65, 0x63, 0x34,
	0x28, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 0x2e, 0x78, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x74, 0x65,
	0x78, 0x2e, 0x79, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 0x2e, 0x7a, 0x2c, 0x20, 0x31,
	0x2e, 0x30, 0x29, 0x3b, 0x0a, 0x7d
};

const char gl_default_pixel_p3[] = {
	0x23, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x33, 0x33, 0x30, 0x0a, 0x6f, 0x75, 0x74,
	0x20, 0x76, 0x65, 0x63, 0x34, 0x20, 0x64, 0x73, 0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x3b, 0x0a,
	0x76, 0x6f, 0x69, 0x64, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x28, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x64,
	0x73, 0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x3d, 0x20, 0x76, 0x65, 0x63, 0x34, 0x28, 0x30,
	0x2e, 0x30, 0x2c, 0x20, 0x30, 0x2e, 0x30, 0x2c, 0x20, 0x30, 0x2e, 0x30, 0x2c, 0x20, 0x31, 0x2e,
	0x30, 0x29, 0x3b, 0x0a, 0x7d
};

const char gl_default_vertex_p3t2[348] = {
	0x23, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x33, 0x33, 0x30, 0x0a, 0x6c, 0x61, 0x79,
	0x6f, 0x75, 0x74, 0x28, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x30,
	0x29, 0x20, 0x69, 0x6e, 0x20, 0x76, 0x65, 0x63, 0x33, 0x20, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78,
	0x3b, 0x0a, 0x6c, 0x61, 0x79, 0x6f, 0x75, 0x74, 0x28, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x20, 0x3d, 0x20, 0x31, 0x29, 0x20, 0x69, 0x6e, 0x20, 0x76, 0x65, 0x63, 0x32, 0x20, 0x74,
	0x65, 0x78, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x3b, 0x0a, 0x6c, 0x61, 0x79, 0x6f, 0x75, 0x74, 0x28,
	0x62, 0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x3d, 0x20, 0x30, 0x29, 0x20, 0x75, 0x6e, 0x69,
	0x66, 0x6f, 0x72, 0x6d, 0x20, 0x63, 0x61, 0x6d, 0x65, 0x72, 0x61, 0x20, 0x7b, 0x0a, 0x09, 0x6d,
	0x61, 0x74, 0x34, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78,
	0x3b, 0x0a, 0x09, 0x6d, 0x61, 0x74, 0x34, 0x20, 0x76, 0x69, 0x65, 0x77, 0x5f, 0x6d, 0x61, 0x74,
	0x72, 0x69, 0x78, 0x3b, 0x0a, 0x09, 0x6d, 0x61, 0x74, 0x34, 0x20, 0x70, 0x72, 0x6f, 0x6a, 0x5f,
	0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x3b, 0x0a, 0x7d, 0x3b, 0x0a, 0x6f, 0x75, 0x74, 0x20, 0x76,
	0x65, 0x63, 0x32, 0x20, 0x64, 0x73, 0x74, 0x54, 0x65, 0x78, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x3b,
	0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x28, 0x29, 0x20, 0x7b, 0x0a, 0x09,
	0x64, 0x73, 0x74, 0x54, 0x65, 0x78, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x20, 0x3d, 0x20, 0x74, 0x65,
	0x78, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x3b, 0x0a, 0x09, 0x67, 0x6c, 0x5f, 0x50, 0x6f, 0x73, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x70, 0x72, 0x6f, 0x6a, 0x5f, 0x6d, 0x61, 0x74, 0x72,
	0x69, 0x78, 0x20, 0x2a, 0x20, 0x76, 0x69, 0x65, 0x77, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78,
	0x20, 0x2a, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x20,
	0x2a, 0x20, 0x76, 0x65, 0x63, 0x34, 0x28, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 0x2e, 0x78, 0x2c,
	0x20, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 0x2e, 0x79, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x74, 0x65,
	0x78, 0x2e, 0x7a, 0x2c, 0x20, 0x31, 0x2e, 0x30, 0x29, 0x3b, 0x0a, 0x7d
};

const char gl_default_pixel_p3t2[] = {
	0x23, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x33, 0x33, 0x30, 0x0a, 0x6c, 0x61, 0x79,
	0x6f, 0x75, 0x74, 0x28, 0x62, 0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x3d, 0x30, 0x29, 0x20, 0x75,
	0x6e, 0x69, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x32, 0x44,
	0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x3b,
	0x0a, 0x69, 0x6e, 0x20, 0x76, 0x65, 0x63, 0x32, 0x20, 0x64, 0x73, 0x74, 0x54, 0x65, 0x78, 0x43,
	0x6f, 0x6f, 0x72, 0x64, 0x3b, 0x0a, 0x6f, 0x75, 0x74, 0x20, 0x76, 0x65, 0x63, 0x34, 0x20, 0x64,
	0x73, 0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x3b, 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x6d, 0x61,
	0x69, 0x6e, 0x28, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x64, 0x73, 0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x72,
	0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x28, 0x74, 0x65, 0x78, 0x74, 0x75,
	0x72, 0x65, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x2c, 0x20, 0x64, 0x73, 0x74, 0x54, 0x65,
	0x78, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x29, 0x3b, 0x0a, 0x7d
};

const char gl_default_vertex_p3t2c4[442] = {
	0x23, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x33, 0x33, 0x30, 0x0a, 0x6c, 0x61, 0x79, 
	0x6f, 0x75, 0x74, 0x28, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x30, 
	0x29, 0x20, 0x69, 0x6e, 0x20, 0x76, 0x65, 0x63, 0x33, 0x20, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 
	0x3b, 0x0a, 0x6c, 0x61, 0x79, 0x6f, 0x75, 0x74, 0x28, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 
	0x6e, 0x20, 0x3d, 0x20, 0x31, 0x29, 0x20, 0x69, 0x6e, 0x20, 0x76, 0x65, 0x63, 0x32, 0x20, 0x74, 
	0x65, 0x78, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x3b, 0x0a, 0x6c, 0x61, 0x79, 0x6f, 0x75, 0x74, 0x28, 
	0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x32, 0x29, 0x20, 0x69, 0x6e, 
	0x20, 0x76, 0x65, 0x63, 0x34, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
	0x3b, 0x0a, 0x6c, 0x61, 0x79, 0x6f, 0x75, 0x74, 0x28, 0x62, 0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67, 
	0x20, 0x3d, 0x20, 0x30, 0x29, 0x20, 0x75, 0x6e, 0x69, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x63, 0x61, 
	0x6d, 0x65, 0x72, 0x61, 0x20, 0x7b, 0x0a, 0x09, 0x6d, 0x61, 0x74, 0x34, 0x20, 0x6d, 0x6f, 0x64, 
	0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x3b, 0x0a, 0x09, 0x6d, 0x61, 0x74, 0x34, 
	0x20, 0x76, 0x69, 0x65, 0x77, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x3b, 0x0a, 0x09, 0x6d, 
	0x61, 0x74, 0x34, 0x20, 0x70, 0x72, 0x6f, 0x6a, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x3b, 
	0x0a, 0x7d, 0x3b, 0x0a, 0x6f, 0x75, 0x74, 0x20, 0x76, 0x65, 0x63, 0x32, 0x20, 0x64, 0x73, 0x74, 
	0x54, 0x65, 0x78, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x3b, 0x0a, 0x6f, 0x75, 0x74, 0x20, 0x76, 0x65, 
	0x63, 0x34, 0x20, 0x64, 0x73, 0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x43, 0x6f, 0x6f, 0x72, 0x64, 
	0x3b, 0x0a, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x28, 0x29, 0x20, 0x7b, 0x0a, 
	0x09, 0x64, 0x73, 0x74, 0x54, 0x65, 0x78, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x20, 0x3d, 0x20, 0x74, 
	0x65, 0x78, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x3b, 0x0a, 0x09, 0x64, 0x73, 0x74, 0x43, 0x6f, 0x6c, 
	0x6f, 0x72, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x20, 0x3d, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x43, 
	0x6f, 0x6f, 0x72, 0x64, 0x3b, 0x0a, 0x09, 0x67, 0x6c, 0x5f, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 
	0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x70, 0x72, 0x6f, 0x6a, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 
	0x20, 0x2a, 0x20, 0x76, 0x69, 0x65, 0x77, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x20, 0x2a, 
	0x20, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x20, 0x2a, 0x20, 
	0x76, 0x65, 0x63, 0x34, 0x28, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 0x2e, 0x78, 0x2c, 0x20, 0x76, 
	0x65, 0x72, 0x74, 0x65, 0x78, 0x2e, 0x79, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 0x2e, 
	0x7a, 0x2c, 0x20, 0x31, 0x2e, 0x30, 0x29, 0x3b, 0x0a, 0x7d
};

const char gl_default_pixel_p3t2c4[] = {
	0x23, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x33, 0x33, 0x30, 0x0a, 0x6c, 0x61, 0x79,
	0x6f, 0x75, 0x74, 0x28, 0x62, 0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x3d, 0x30, 0x29, 0x20, 0x75,
	0x6e, 0x69, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x32, 0x44,
	0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x3b,
	0x0a, 0x69, 0x6e, 0x20, 0x76, 0x65, 0x63, 0x32, 0x20, 0x64, 0x73, 0x74, 0x54, 0x65, 0x78, 0x43,
	0x6f, 0x6f, 0x72, 0x64, 0x3b, 0x0a, 0x69, 0x6e, 0x20, 0x76, 0x65, 0x63, 0x34, 0x20, 0x64, 0x73,
	0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x3b, 0x0a, 0x6f, 0x75, 0x74,
	0x20, 0x76, 0x65, 0x63, 0x34, 0x20, 0x64, 0x73, 0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x3b, 0x0a,
	0x76, 0x6f, 0x69, 0x64, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x28, 0x29, 0x20, 0x7b, 0x0a, 0x09, 0x64,
	0x73, 0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72,
	0x65, 0x28, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72,
	0x2c, 0x20, 0x64, 0x73, 0x74, 0x54, 0x65, 0x78, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x29, 0x20, 0x2a,
	0x20, 0x64, 0x73, 0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x43, 0x6f, 0x6f, 0x72, 0x64, 0x3b, 0x0a,
	0x7d
};

using namespace Mazeline;

GLuint g_ibRectangleID;
const int g_3dRectangleIndices[6]{ 0, 1, 2, 2, 0, 3 };
GLuint g_vbRectangleID;
float g_3dRectangleVerts[12];
GLuint g_defaultMesh;

int g_shader_p3;
int g_shader_p3t2;
int g_shader_p3t2c4;

GLenum g_shaderTypeMappings[2]{
	GL_VERTEX_SHADER,
	GL_FRAGMENT_SHADER
};

GLenum g_primitiveMappings[5]{
	GL_POINTS,
	GL_LINES,
	GL_TRIANGLES,
	GL_TRIANGLE_STRIP,
	GL_QUADS
};

GLenum g_shaderDataTypeMappings[2]{
	GL_UNIFORM_BUFFER,
	GL_SHADER_STORAGE_BUFFER
};

OpenGLApi::OpenGLApi() {
	m_hasInitd = false;
	m_shaderErrLog = 0;
	m_shaderErrLogLen = 0;
}

void OpenGLApi::SetClearColor(float r, float g, float b, float a) {
	glClearColor(r, g, b, a);
}

void OpenGLApi::ClearScreen(FrameBufferTarget target) {
	GLbitfield mask = 0;
	if (target & FrameBufferTarget::FBTColor) mask |= GL_COLOR_BUFFER_BIT;
	if (target & FrameBufferTarget::FBTDepth) mask |= GL_DEPTH_BUFFER_BIT;
	if (target & FrameBufferTarget::FBTStencil) mask |= GL_STENCIL_BUFFER_BIT;
	if (mask)
		glClear(mask);
}

void OpenGLApi::ClearColor() {
	glClear(GL_COLOR_BUFFER_BIT);
}

void OpenGLApi::ClearDepth() {
	glClear(GL_DEPTH_BUFFER_BIT);
}

void OpenGLApi::ClearStencil() {
	glClear(GL_STENCIL_BUFFER_BIT);
}

#ifndef NDEBUG
void GLAPIENTRY MessageCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* msg, const void* userParam) {
	printf("GL CALLBACK: %s type = 0x%x, severity = 0x%x, message = %s\n",
		(type == GL_DEBUG_TYPE_ERROR ? "** GL ERROR **" : ""), type, severity, msg);
}
#endif

void create_shaders(OpenGLApi* api) {
	ShaderSource p3[2]{
		{ ShaderType::STVertex, const_cast<char*>(&gl_default_vertex_p3[0]), sizeof(gl_default_vertex_p3), false, 0, 0 },
		{ ShaderType::STPixel, const_cast<char*>(&gl_default_pixel_p3[0]), sizeof(gl_default_pixel_p3), false, 0, 0 }
	};

	int success = api->CreateShader(g_shader_p3, 2, &p3[0]);

	p3[0].Data = const_cast<char*>(&gl_default_vertex_p3t2[0]);
	p3[0].Length = sizeof(gl_default_vertex_p3t2);
	p3[1].Data = const_cast<char*>(&gl_default_pixel_p3t2[0]);
	p3[1].Length = sizeof(gl_default_pixel_p3t2);

	success |= api->CreateShader(g_shader_p3t2, 2, &p3[0]);

	p3[0].Data = const_cast<char*>(&gl_default_vertex_p3t2c4[0]);
	p3[0].Length = sizeof(gl_default_vertex_p3t2c4);
	p3[1].Data = const_cast<char*>(&gl_default_pixel_p3t2c4[0]);
	p3[1].Length = sizeof(gl_default_pixel_p3t2c4);

	success |= api->CreateShader(g_shader_p3t2c4, 2, &p3[0]);
}

void OpenGLApi::Initialise() {
	if (m_hasInitd)
		return;

#ifndef NDEBUG
	glEnable(GL_DEBUG_OUTPUT);
	glDebugMessageCallback(MessageCallback, 0);
#endif

	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	create_shaders(this);

	glGenVertexArrays(1, &g_defaultMesh);

	glGenBuffers(1, &g_vbRectangleID);
	glBindBuffer(GL_ARRAY_BUFFER, g_vbRectangleID);
	glBufferData(GL_ARRAY_BUFFER, sizeof(g_3dRectangleVerts), 0, GL_DYNAMIC_DRAW);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);
	glBindBuffer(GL_ARRAY_BUFFER, 0);

	glGenBuffers(1, &g_ibRectangleID);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_ibRectangleID);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(g_3dRectangleIndices), &g_3dRectangleIndices[0], GL_STATIC_DRAW);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

	m_hasInitd = true;
}

void OpenGLApi::DrawRectangle(float x, float y, float w, float h) {
	if (!m_hasInitd)
		return;
	float *p = &g_3dRectangleVerts[0];
	*p++ = x; *p++ = y; *p++ = 0;
	*p++ = x + w; *p++ = y; *p++ = 0;
	*p++ = x + w; *p++ = y + h; *p++ = 0;
	*p++ = x; *p++ = y + h; *p++ = 0;

	glBindBuffer(GL_ARRAY_BUFFER, g_vbRectangleID);
	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(g_3dRectangleVerts), &g_3dRectangleVerts[0]);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, g_ibRectangleID);
	glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, (void*)0);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
}

int OpenGLApi::CreateShader(int& shaderHandle, int numSources, ShaderSource *sources) {
	ShaderSource* src = sources;

	int *shaderIds = new int[numSources];
	int compileStatus = 0;

	// Stage 1: Compile all the shaders
	for (int i = 0; i < numSources; i++, src++) {
		if (src->Length < 0) {
			if (m_shaderErrLogLen > 0)
				delete[] m_shaderErrLog;
			//m_shaderErrLog = new char { "Shader source not given." };
			alloc_char_wstr(m_shaderErrLog, "Shader source not given.");
			m_shaderErrLogLen = strlen(m_shaderErrLog) + 1;
			delete[] shaderIds;
			return m_shaderErrLogLen;
		}

		if (src->Type < 0 || src->Type > 1) {
			if (m_shaderErrLogLen > 0)
				delete[] m_shaderErrLog;
			//m_shaderErrLog = new char[] { "Invalid shader type" };
			m_shaderErrLogLen = strlen(m_shaderErrLog) + 1;
			alloc_char_wstr(m_shaderErrLog, "Invalid shader type");
			delete[] shaderIds;
			return m_shaderErrLogLen;
		}

		shaderIds[i] = glCreateShader(g_shaderTypeMappings[src->Type]);
		glShaderSource(shaderIds[i], 1, &src->Data, &src->Length);
		glCompileShader(shaderIds[i]);

		glGetShaderiv(shaderIds[i], GL_COMPILE_STATUS, &compileStatus);
		
		if (!compileStatus) {
			if (m_shaderErrLogLen > 0)
				delete[] m_shaderErrLog;
			glGetShaderiv(shaderIds[i], GL_INFO_LOG_LENGTH, &m_shaderErrLogLen);
			
			if (m_shaderErrLogLen <= 0) {
				//m_shaderErrLog = new char[] { "A shader compilation error occurred but the error log is empty. Hmm..."};
				alloc_char_wstr(m_shaderErrLog, "A shader compilation error occurred but the error log is empty. Hmm...");
				m_shaderErrLogLen = strlen(m_shaderErrLog) + 1;
			}
			else {
				m_shaderErrLog = new char[m_shaderErrLogLen];
				glGetShaderInfoLog(shaderIds[i], m_shaderErrLogLen, &m_shaderErrLogLen, m_shaderErrLog);
			}
			delete[] shaderIds;
			return m_shaderErrLogLen;
		}
	}

	// Stage 2: Create the program and link all the shaders
	shaderHandle = glCreateProgram();

	for (int i = 0; i < numSources; i++)
		glAttachShader(shaderHandle, shaderIds[i]);
	glLinkProgram(shaderHandle);
	for (int i = 0; i < numSources; i++) {
		glDetachShader(shaderHandle, shaderIds[i]);
		glDeleteShader(shaderIds[i]);
	}

	int linkStatus;
	glGetProgramiv(shaderHandle, GL_LINK_STATUS, &linkStatus);

	if (!linkStatus) {
		if (m_shaderErrLogLen > 0)
			delete[] m_shaderErrLog;
		glGetProgramiv(shaderHandle, GL_INFO_LOG_LENGTH, &m_shaderErrLogLen);
		
		if (m_shaderErrLogLen <= 0) {
			//m_shaderErrLog = new char[] { "A shader linkage error occurred but the error log is empty. Hmm..."};
			alloc_char_wstr(m_shaderErrLog, "A shader compilation error occurred but the error log is empty. Hmm...");
			m_shaderErrLogLen = strlen(m_shaderErrLog) + 1;
		}
		else {
			m_shaderErrLog = new char[m_shaderErrLogLen];
			glGetProgramInfoLog(shaderHandle, m_shaderErrLogLen, &m_shaderErrLogLen, m_shaderErrLog);
		}
		delete[] shaderIds;
		return m_shaderErrLogLen;
	}

	// Finally, we made a shader!
	delete[] shaderIds;
	return 0;
}

bool OpenGLApi::GetShaderError(char* container, int length) {
	if (m_shaderErrLogLen < 1)
		return false;
	strncpy_s(container, length, m_shaderErrLog, length);
	return true;
}

void OpenGLApi::ActivateShader(int shaderId) {
	glUseProgram(shaderId);
}

void OpenGLApi::ActivateCoreShader(DefaultShader shader) {
	switch (shader) {
	case DefaultShader::DSVertex:
		glUseProgram(g_shader_p3);
		break;
	case DefaultShader::DSColoredVertex:
		break; // TODO: Implement
	case DefaultShader::DSTexturedVertex:
		glUseProgram(g_shader_p3t2);
		break;
	case DefaultShader::DSColTexVertex:
		glUseProgram(g_shader_p3t2c4);
		break;
	}
}

int OpenGLApi::CreateShaderDataBinding(ShaderDataBinding bindingType, int location, int sizeInBytes) {
	GLuint id;
	glGenBuffers(1, &id);
	glBindBuffer(g_shaderDataTypeMappings[bindingType], id);
	glBufferData(g_shaderDataTypeMappings[bindingType], sizeInBytes, 0, GL_DYNAMIC_DRAW);
	glBindBufferBase(g_shaderDataTypeMappings[bindingType], location, id);
	glBindBuffer(g_shaderDataTypeMappings[bindingType], 0);
	return id;
}

void OpenGLApi::SetShaderConstantData(int location, void* data, int start, int copySizeInBytes) {
	glBindBuffer(GL_UNIFORM_BUFFER, location);
	glBufferSubData(GL_UNIFORM_BUFFER, start, copySizeInBytes, data);
	glBindBuffer(GL_UNIFORM_BUFFER, 0);
}

void OpenGLApi::SetShaderVariableData(int location, void* data, int start, int copySizeInBytes) {
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, location);
	glBufferSubData(GL_SHADER_STORAGE_BUFFER, start, copySizeInBytes, data);
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

void OpenGLApi::DeleteShaderDataBinding(ShaderDataBinding bindingType, int location, int binding) {
	glBindBufferBase(g_shaderDataTypeMappings[bindingType], location, 0);
	GLuint id = binding;
	glDeleteBuffers(1, &id);
}

void OpenGLApi::DeleteShader(int shaderId) {
	glDeleteProgram(shaderId);
}

int OpenGLApi::CreateBuffer() {
	GLuint id;
	glGenBuffers(1, &id);
	return id;
}

void OpenGLApi::AllocateBuffer(int bufferId, int size, void* data, int offset, int copySizeInBytes) {
	glBindBuffer(GL_ARRAY_BUFFER, bufferId);
	glBufferData(GL_ARRAY_BUFFER, size, 0, GL_DYNAMIC_DRAW);
	if (data)
		glBufferSubData(GL_ARRAY_BUFFER, offset, copySizeInBytes, data);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
}

void OpenGLApi::AllocateIndexBuffer(int bufferId, int size, void* data, int offset, int copySizeInBytes) {
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bufferId);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, size, 0, GL_DYNAMIC_DRAW);
	if (data)
		glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, offset, copySizeInBytes, data);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
}

void OpenGLApi::SetBufferData(int bufferId, void* data, int offset, int copySizeInbytes) {
	glBindBuffer(GL_ARRAY_BUFFER, bufferId);
	glBufferSubData(GL_ARRAY_BUFFER, offset, copySizeInbytes, data);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
}

void OpenGLApi::SetIndexBufferData(int bufferId, void* data, int offset, int copySizeInbytes) {
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, bufferId);
	glBufferSubData(GL_ELEMENT_ARRAY_BUFFER, offset, copySizeInbytes, data);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
}

void OpenGLApi::DeleteBuffer(int bufferId) {
	GLuint id = bufferId;
	glDeleteBuffers(1, &id);
}

int OpenGLApi::CreateMesh() {
	GLuint id;
	glGenVertexArrays(1, &id);
	return id;
}

int get_element_count(InputElementFormat format) {
	switch (format) {
	case InputElementFormat::R32:
	case InputElementFormat::R8:
		return 1;
	case InputElementFormat::R32G32:
	case InputElementFormat::R8G8:
		return 2;
	case InputElementFormat::R32G32B32:
	case InputElementFormat::R8G8B8:
		return 3;
	case InputElementFormat::R32G32B32A32:
	case InputElementFormat::R8G8B8A8:
		return 4;
	default:
		return 0;
	}
}

GLenum get_element_type(InputElementFormat format) {
	switch (format) {
	case InputElementFormat::R32:
	case InputElementFormat::R32G32:
	case InputElementFormat::R32G32B32:
	case InputElementFormat::R32G32B32A32:
		return GL_FLOAT;
	case InputElementFormat::R8:
	case InputElementFormat::R8G8:
	case InputElementFormat::R8G8B8:
	case InputElementFormat::R8G8B8A8:
		return GL_UNSIGNED_BYTE;
	}
}

void OpenGLApi::UseMeshLayout(int meshId, int numElements, InputElement* elements, bool update) {
	// TODO: Cache layouts rather than recreating them all the time!
	if (meshId == 0) meshId = g_defaultMesh;

	InputElement* element = elements;

	glBindVertexArray(meshId);

	for (int i = 0; i < numElements; i++, element++) {
		glBindBuffer(GL_ARRAY_BUFFER, element->BufferId);
		glEnableVertexArrayAttrib(meshId, element->BufferLocation);
		glVertexAttribPointer(
			element->BufferLocation,
			get_element_count(element->Format),
			get_element_type(element->Format),
			GL_FALSE,
			element->Stride,
			(void*)element->ByteOffset
		);
	}
}

void OpenGLApi::DeleteMesh(int meshId) {
	GLuint id = meshId;
	glDeleteVertexArrays(1, &id);
}

void OpenGLApi::DrawMesh(int meshId, PrimitiveType type, int vertexCount, int offset) {
	if (meshId == 0) meshId = g_defaultMesh;
	glBindVertexArray(meshId);
	glDrawArrays(g_primitiveMappings[type], offset, vertexCount);
}

void OpenGLApi::DrawIndexedMesh(int meshId, int indexId, PrimitiveType type, int indexCount, int offset) {
	if (meshId == 0) meshId = g_defaultMesh;
	glBindVertexArray(meshId);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexId);
	glDrawElements(g_primitiveMappings[type], indexCount, GL_UNSIGNED_INT, (void*)offset);
}

GLenum get_image_type(PixelFormat format) {
	switch (format) {
	case PixelFormat::PF_8_Grayscale:
	case PixelFormat::PF_16_Grayscale:
		return GL_RED;
	case PixelFormat::PF_16_GrayscaleA:
	case PixelFormat::PF_32_GrayscaleA:
		return GL_RG;
	case PixelFormat::PF_24_RGB:
	case PixelFormat::PF_48_RGB:
		return GL_RGB;
	case PixelFormat::PF_32_RGBA:
	case PixelFormat::PF_64_RGBA:
	default:
		return GL_RGBA;
	}
}

GLenum get_image_format(PixelFormat format) {
	switch (format) {
	case PixelFormat::PF_8_Grayscale:
	case PixelFormat::PF_16_GrayscaleA:
	case PixelFormat::PF_24_RGB:
	case PixelFormat::PF_32_RGBA:
	default:
		return GL_UNSIGNED_BYTE;
	case PixelFormat::PF_16_Grayscale:
	case PixelFormat::PF_32_GrayscaleA:
	case PixelFormat::PF_48_RGB:
	case PixelFormat::PF_64_RGBA:
		return GL_UNSIGNED_SHORT;
	}
}

int OpenGLApi::CreateTexture(Bitmap* bmp) {
	GLuint id;
	glGenTextures(1, &id);
	glBindTexture(GL_TEXTURE_2D, id);
	glTexImage2D(GL_TEXTURE_2D,
		0,
		GL_RGBA,
		bmp->GetWidth(),
		bmp->GetHeight(),
		0,
		get_image_type(bmp->GetPixelFormat()),
		get_image_format(bmp->GetPixelFormat()),
		bmp->GetPixelData());
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glBindTexture(GL_TEXTURE_2D, 0);
	return id;
}

void OpenGLApi::UseTexture(int slot, int textureId) {
	glEnable(GL_TEXTURE_2D);
	glActiveTexture(GL_TEXTURE0 + slot);
	glBindTexture(GL_TEXTURE_2D, textureId);
}

void OpenGLApi::DeleteTexture(int textureId) {
	GLuint id = textureId;
	glDeleteTextures(1, &id);
}

OpenGLApi::~OpenGLApi() {
	if (m_shaderErrLogLen > 0)
		delete[] m_shaderErrLog;
}